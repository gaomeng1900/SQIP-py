
/*
@author Meng G. <gaomeng1900@gmail.com>
@date 2016-03-21
@github https://github.com/gaomeng1900/centralperk

Support ADM/commonJS/global
 */
(function(global, factory) {
  if (typeof exports === 'object' && typeof module !== 'undefined') {
    return module.exports = factory();
  } else {
    if (typeof define === 'function' && define.amd) {
      return define(['PERK'], factory);
    } else {
      return global.PERK = factory();
    }
  }
})(this, function() {
  var PERK, Requests, SOFA;
  if (typeof define === 'function' && define.amd) {
    Requests = require('requests');
  }
  SOFA = {
    $$funMap: {},
    links: {}
  };
  PERK = {
    sign: function(taskID, fun) {
      SOFA.$$funMap[taskID] = fun;
    },
    link: function(root) {
      var stream;
      stream = [root];
      SOFA.links[root] = {};
      return {
        stream: stream,
        to: function(branch, leaf) {
          return PERK.linker.call(this, branch, leaf);
        }
      };
    },
    linker: function(branch, leaf) {
      var _l, i, j, k, len, len1, ref, root, stream;
      root = SOFA.links[this.stream[0]];
      if (leaf) {
        if (!PERK._isArray(leaf)) {
          leaf = [leaf];
        }
        for (j = 0, len = leaf.length; j < len; j++) {
          _l = leaf[j];
          root[_l] = {};
        }
      }
      ref = this.stream;
      for (k = 0, len1 = ref.length; k < len1; k++) {
        i = ref[k];
        if (i !== this.stream[0]) {
          root = root[i];
        }
      }
      root[branch] = {};
      stream = this.stream.concat(branch);
      return {
        stream: stream,
        to: function(branch, leaf) {
          return PERK.linker.call(this, branch, leaf);
        }
      };
    },
    task: function(taskName, args) {
      return SOFA.$$funMap[taskName](args, function(args) {
        return PERK.next(taskName, [taskName], args);
      });
    },
    next: function(taskName, stream, args) {
      var i, j, len, new_stream, next_step, root;
      root = SOFA.links[stream[0]];
      if (root === void 0) {
        console.log('no follwers');
        return;
      }
      for (j = 0, len = stream.length; j < len; j++) {
        i = stream[j];
        if (i !== stream[0]) {
          root = root[i];
        }
      }
      for (next_step in root) {
        console.log(taskName, '->', next_step);
        if (stream.slice(-1)[0] === next_step) {
          console.error(stream, '->', next_step);
          throw new Error('Dead loop!!! please check your flow');
          return;
        }
        new_stream = function() {
          return stream.concat(next_step);
        };
        SOFA.$$funMap[next_step](args, function(args) {
          return PERK.next(next_step, new_stream(), args);
        });
      }
    },
    stream: function(flow) {
      var results, root;
      console.log(flow);
      results = [];
      for (root in flow) {
        console.log(root);
        results.push(SOFA.links[root] = flow[root]);
      }
      return results;
    },
    get: function(opt, args, done) {
      return PERK._HTTP('get', opt, args, done);
    },
    post: function(opt, args, done) {
      return PERK._HTTP('post', opt, args, done);
    },
    put: function(opt, args, done) {
      return PERK._HTTP('put', opt, args, done);
    },
    "delete": function(opt, args, done) {
      return PERK._HTTP('delete', opt, args, done);
    },
    _HTTP: function(method, opt, args, done) {
      if ((PERK._isArray(args)) || !args[0]) {
        console.warn('ARGS FOOR HTTP should be a Object or Map, OR THE RESULT MAY BE MASSED UP!!');
      }
      if (opt.load_arg) {
        console.warn('OU SHOULDNT PASS CALLBACK_ARGS HERE, NOT HERE, it will be COVERED by args');
      }
      opt.load_arg = args;
      if (opt.load) {
        console.warn('YOU SHOULDNT PASS A LOAD FUNCTION HERE, it will be COVERED by the to(fun)');
      }
      opt.load = done;
      if (!opt.error) {
        opt.error = done;
      }
      return new Requests(opt)[method]();
    },
    _isArray: function(o) {
      return Object.prototype.toString.call(o) === '[object Array]';
    }
  };
  return PERK;
});

//# sourceMappingURL=data:application/json;base64,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LENBQUQ7YUFDVixNQUFNLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxJQUExQixDQUErQixDQUEvQixDQUFBLEtBQXFDO0lBRDNCLENBOUZYOztBQWlHRCxTQUFPO0FBNUdBLENBUFIiLCJmaWxlIjoiY2VudHJhbHBlcmsuanMiLCJzb3VyY2VSb290IjoiL3NvdXJjZS8iLCJzb3VyY2VzQ29udGVudCI6WyIjIyNcbkBhdXRob3IgTWVuZyBHLiA8Z2FvbWVuZzE5MDBAZ21haWwuY29tPlxuQGRhdGUgMjAxNi0wMy0yMVxuQGdpdGh1YiBodHRwczovL2dpdGh1Yi5jb20vZ2FvbWVuZzE5MDAvY2VudHJhbHBlcmtcblxuU3VwcG9ydCBBRE0vY29tbW9uSlMvZ2xvYmFsXG5cbiMjI1xuXG5cblxuKChnbG9iYWwsIGZhY3RvcnkpLT5cbiAgICBpZiB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnIFxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKVxuICAgIGVsc2VcbiAgICAgICAgaWYgdHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWRcbiAgICAgICAgICAgIGRlZmluZShbJ1BFUksnXSwgZmFjdG9yeSkgXG4gICAgICAgIGVsc2UgZ2xvYmFsLlBFUksgPSBmYWN0b3J5KClcbikodGhpcywgKCktPlxuXG5cdGlmIHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kXG5cdFx0UmVxdWVzdHMgPSByZXF1aXJlICdyZXF1ZXN0cydcblxuXHRTT0ZBPVxuXHRcdCQkZnVuTWFwOnt9XG5cdFx0bGlua3M6e31cblxuXHRQRVJLID1cblxuXHRcdHNpZ246ICh0YXNrSUQsIGZ1biktPlxuXHRcdFx0U09GQS4kJGZ1bk1hcFt0YXNrSURdID0gZnVuXG5cdFx0XHRyZXR1cm5cblxuXHRcdGxpbms6KHJvb3QpLT5cblx0XHRcdHN0cmVhbSA9IFtyb290XVxuXHRcdFx0U09GQS5saW5rc1tyb290XSA9IHt9XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRzdHJlYW06c3RyZWFtXG5cdFx0XHRcdHRvOiAoYnJhbmNoLCBsZWFmKS0+XG5cdFx0XHRcdFx0UEVSSy5saW5rZXIuY2FsbCh0aGlzLCBicmFuY2gsIGxlYWYpXG5cdFx0XHR9XG5cblx0XHRsaW5rZXI6KGJyYW5jaCwgbGVhZiktPlxuXHRcdFx0cm9vdCA9IFNPRkEubGlua3NbQHN0cmVhbVswXV1cblxuXHRcdFx0aWYgbGVhZlxuXHRcdFx0XHRpZiBub3QgUEVSSy5faXNBcnJheSBsZWFmXG5cdFx0XHRcdFx0bGVhZiA9IFtsZWFmXVxuXHRcdFx0XHRmb3IgX2wgaW4gbGVhZlxuXHRcdFx0XHRcdHJvb3RbX2xdID0ge31cblx0XHRcdFxuXHRcdFx0Zm9yIGkgaW4gQHN0cmVhbSB3aGVuIGkgIT0gQHN0cmVhbVswXVxuXHRcdFx0XHRyb290ID0gcm9vdFtpXVxuXHRcdFx0cm9vdFticmFuY2hdID0ge31cblx0XHRcdHN0cmVhbSA9IEBzdHJlYW0uY29uY2F0IGJyYW5jaFxuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRzdHJlYW06c3RyZWFtXG5cdFx0XHRcdHRvOiAoYnJhbmNoLCBsZWFmKS0+XG5cdFx0XHRcdFx0UEVSSy5saW5rZXIuY2FsbCh0aGlzLCBicmFuY2gsIGxlYWYpXG5cdFx0XHR9XG5cblx0XHR0YXNrOih0YXNrTmFtZSwgYXJncyktPlxuXHRcdFx0U09GQS4kJGZ1bk1hcFt0YXNrTmFtZV0gYXJncywgKGFyZ3MpLT4gXG5cdFx0XHRcdFBFUksubmV4dCB0YXNrTmFtZSwgW3Rhc2tOYW1lXSwgYXJnc1xuXG5cdFx0bmV4dDoodGFza05hbWUsIHN0cmVhbSwgYXJncyktPlxuXHRcdFx0cm9vdCA9IFNPRkEubGlua3Nbc3RyZWFtWzBdXVxuXG5cdFx0XHRpZiByb290ID09IHVuZGVmaW5lZFxuXHRcdFx0XHRjb25zb2xlLmxvZyAnbm8gZm9sbHdlcnMnXG5cdFx0XHRcdHJldHVybiBcblx0XHRcdGZvciBpIGluIHN0cmVhbSB3aGVuIGkgIT0gc3RyZWFtWzBdXG5cdFx0XHRcdHJvb3QgPSByb290W2ldXG5cblx0XHRcdGZvciBuZXh0X3N0ZXAgb2Ygcm9vdFxuXHRcdFx0XHRjb25zb2xlLmxvZyB0YXNrTmFtZSwgJy0+JywgbmV4dF9zdGVwXG5cdFx0XHRcdCMgSU1QT1JUQU5UISEhXG5cdFx0XHRcdGlmIHN0cmVhbS5zbGljZSgtMSlbMF0gPT0gbmV4dF9zdGVwXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciBzdHJlYW0sICctPicsIG5leHRfc3RlcFxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciAnRGVhZCBsb29wISEhIHBsZWFzZSBjaGVjayB5b3VyIGZsb3cnXG5cdFx0XHRcdFx0cmV0dXJuXG5cblx0XHRcdFx0bmV3X3N0cmVhbSA9ICgpLT4gc3RyZWFtLmNvbmNhdCBuZXh0X3N0ZXBcblx0XHRcdFx0XG5cdFx0XHRcdFNPRkEuJCRmdW5NYXBbbmV4dF9zdGVwXSBhcmdzLCAoYXJncyktPiBcblx0XHRcdFx0XHRQRVJLLm5leHQgbmV4dF9zdGVwLCBuZXdfc3RyZWFtKCksIGFyZ3NcblxuXG5cdFx0c3RyZWFtOihmbG93KS0+XG5cdFx0XHRjb25zb2xlLmxvZyBmbG93XG5cdFx0XHRmb3Igcm9vdCBvZiBmbG93XG5cdFx0XHRcdGNvbnNvbGUubG9nIHJvb3Rcblx0XHRcdFx0U09GQS5saW5rc1tyb290XSA9IGZsb3dbcm9vdF1cblxuXG5cdFx0IyBSZXF1ZXN0cyByZXF1aXJlZFxuXG5cdFx0Z2V0OihvcHQsIGFyZ3MsIGRvbmUpLT5cblx0XHRcdFBFUksuX0hUVFAgJ2dldCcsIG9wdCwgYXJncywgZG9uZVxuXHRcdHBvc3Q6KG9wdCwgYXJncywgZG9uZSktPlxuXHRcdFx0UEVSSy5fSFRUUCAncG9zdCcsIG9wdCwgYXJncywgZG9uZVxuXHRcdHB1dDoob3B0LCBhcmdzLCBkb25lKS0+XG5cdFx0XHRQRVJLLl9IVFRQICdwdXQnLCBvcHQsIGFyZ3MsIGRvbmVcblx0XHRkZWxldGU6KG9wdCwgYXJncywgZG9uZSktPlxuXHRcdFx0UEVSSy5fSFRUUCAnZGVsZXRlJywgb3B0LCBhcmdzLCBkb25lXG5cblx0XHRfSFRUUDoobWV0aG9kLCBvcHQsIGFyZ3MsIGRvbmUpLT5cblx0XHRcdGlmIChQRVJLLl9pc0FycmF5IGFyZ3MpIG9yIG5vdCBhcmdzWzBdXG5cdFx0XHRcdGNvbnNvbGUud2FybiAnQVJHUyBGT09SIEhUVFAgc2hvdWxkIGJlIGEgT2JqZWN0IG9yIE1hcCwgT1IgVEhFIFJFU1VMVCBNQVkgQkUgTUFTU0VEIFVQISEnXG5cdFx0XHRpZiBvcHQubG9hZF9hcmdcblx0XHRcdFx0Y29uc29sZS53YXJuICdPVSBTSE9VTEROVCBQQVNTIENBTExCQUNLX0FSR1MgSEVSRSwgTk9UIEhFUkUsIGl0IHdpbGwgYmUgQ09WRVJFRCBieSBhcmdzJ1xuXHRcdFx0b3B0LmxvYWRfYXJnID0gYXJnc1xuXHRcdFx0aWYgb3B0LmxvYWRcblx0XHRcdFx0Y29uc29sZS53YXJuICdZT1UgU0hPVUxETlQgUEFTUyBBIExPQUQgRlVOQ1RJT04gSEVSRSwgaXQgd2lsbCBiZSBDT1ZFUkVEIGJ5IHRoZSB0byhmdW4pJ1xuXHRcdFx0b3B0LmxvYWQgPSBkb25lXG5cdFx0XHRpZiBub3Qgb3B0LmVycm9yXHRcdFxuXHRcdFx0XHRvcHQuZXJyb3IgPSBkb25lXG5cdFx0XHRuZXcgUmVxdWVzdHMob3B0KVttZXRob2RdKClcblxuXG5cdFx0IyBoZWxwZXJzXG5cblx0XHRfaXNBcnJheSA6IChvKS0+XG5cdFx0XHRPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykgPT0gJ1tvYmplY3QgQXJyYXldJ1xuXG5cdHJldHVybiBQRVJLXG5cbikiXX0=
